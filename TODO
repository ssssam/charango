Charango 0.3.0 ...

To do (stuff I won't really do)
-------------------------------

* Look at libmodel, how does that relate?
  - interestingly. libmodel takes a very different approach, lower-level than
  anything in charango. Other than the weird idea of having integers etc.
  descend from GObject it's good stuff, but the best use for us would be as
  a way to present views as an alternative to GtkTreeModel. Anything else
  has no real use for me.

* look at meego music player, apparently everything has been done for you !!!!

-> disable static build, add a 'waf run' command similar to 'libtool exec' to fix ld_library_path.

-> Fix waf no longer keeping the vala c output because a c file is included in the build

To do next
----------

Entity:
* type system
  - type information stored and checking before assignment

  -> make the xsd basic types built-in classes

  * DO YOU NEED an id system for classes/types when they are always in memory????????

* Value storage is enourmously inefficient currently because we store all
  integer values as a pointer to a heap-allocated 64 bit int. I guess the
  ideal system is to dynamically store numeric values in the smallest
  possible size, so word-size by default and then up to bigint if
  necessary. I think I will just make the value union 8 bytes.
 - especially since we probably mostly store strings :)

I had  an idea (not sure if necessary) that we should have one giant 'Resource'
hash table that could somehow identify a URI as type, class, property or entity.
This could just be done with a pointer, if we gave maybe the base type values
Vala object types as well.

* avoid duplication of value in setter (see C code for entity.c)

> store data values:
  - read property type from ontology, & build type table from read types
  - finish entity

  Property types are set with
    rdfs:range
  Custom types are defined in time-entry.owl, for one, .. which makes sense.
  This is a strict property, violations are 'datatype clashes', 'XSD inconsistent'

* Since you're using Vala, why not use GValue since it's built in!!

* Improve the look of the class & ontology classes, we can read rdf in a neater way :)

* The store/source interface (beginnings are stashed)
  

-> then examples/basic should work!
--------------------------------------------
The tests are HORRIBLE! Let's just use valadate or improve gtest in vala or something.
This is a joke!
https://bugzilla.gnome.org/show_bug.cgi?id=645178
-------------------------------------------

* Thoughts on libmodel:
  - need to investigate it properly of course
  - aim to provide a generic data model on top of Tracker, but with other uses -
    maybe aiming too high? surely tracker wasn't their only use case. Seems like
    higher level abstractions ontop of eg. glist is a waste of time though. I
    am probably missing something.
  - not an object mapping like charango, more low level. charango forces a
    specific way of working, but a fairly reasonable one
  - maybe charango could integrate it? can't think of a need other than to
    not have to write our own type system - need to see what libmodel does
    here.

Might be nice to have read-only entitys? You can't edit them unless (a) they're
new or (b) they've been checked out. Then again, it's just a flag, it doesn't
really allow us any easier logic.

How could you possibly implement reference tracking?
Vala REALLY needs #define etc ... much as they would probably hate it.
There's simply no other way to do entity ref tracking in a transparent
way, and it was REALLY useful. Wait actually you might be able to do
it using default parameters, even if you have to write the actual
Entity code in C. Better look into this business.

* Handle librdf parse errors by calling librdf_world_set_logger(). Would be nice
  if we could print as many errors as possible rather than just raising an
  exception on the first one. I guess we could return them all to the context
  as Warnings, then raise our own ParseError once the parser has completed
  with a list of all the warnings. This seems kind of an abuse of Warning since
  they aren't warnings, they are errors, we just don't want to fail on the first
  one. Is there a better way? Yeah, make a separate ParseError class which we
  accumulate in the logger .. this makes no sense though, and the errors could
  come from anywhere, not just the parser. Options are:
    - in the .vapi, provide a logger and have the World provide a simple error
      query interface. Don't like this.
    - link with the GLib logger somehow, then we can disable fail on errors
      perhaps while we are parsing. Maybe. Seems like that's a winner for the
      librdf warnings at least.
    - I think eventually you will have to create a list of RedlandParseError
      messages and query them after the parse, however you go about this
      other stuff.
--> librdf parse errors not caught :(
  - Actually I just thought about this again, and the sensible thing to do is to
    turn the parse errors into exceptions but then when we catch one, carry on
    parsing. I constantly forget that exceptions are actually a pretty powerful
    mechanism.

-> We should start warning on unrecognised predicates for classes and properties too.


-> write some tests

-> write some of calliope :)

Things still to handle:
rdfs:isDefinedBy on classes (check it matches where we have added it :)


* Share the vala bindings for librdf


WHERE FROM is a slight issue - we can get them on disk from various locations
(apps own dir, tracker dir) or from the net (canonical sources).

There can be discrepencies/version mismatches, so this is important stuff .. I
guess we should check things when they are stored (perhaps optionally) that they
map to the ontologies stored by *that* storage backend. Ie. we could check that the
data fits an installed Tracker ontology. Or just check the lastModifiedDate property.

Write a generic charango-driven browser for all semantic data sources!!!
See: nepomukshell/ nepsak from KDE


So we need:
* Model
  Charango.Store
  -> Charango.GenericStore, Charango.TrackerStore, Charango.SQLiteStore
  Charango.Source
  -> for web API end points, maybe pluggable? Seems like overkill.
  Charango.Union
  -> for aggregated data sources.

* View ..
  Charango.View, Charango.TreeView .. in the distant future maybe some
  cool faceted browing viewers :)

* Other stuff..
  in the Ontology, we have Classes and Properties
  in the data store, we have Resources ..

Backends: pluggable on run or compile?
ie. if charango is built without tracker support, do we allow calliope to link to .trackerStore?
-> certainly don't want a hard dep on tracker, what about win32? etc.
-> I guess a store needs an available? method

I'm rethinking not requiring the Tracker dep. Surely implementing a simple RDF store
using SQLite is basically reimplementing tracker without the DBUS? Since the only
place it's really hard to expect tracker is win32, surely we can just build it there
using some hacks if necessary.

Truth is Tracker don't want custom ontologies, and it is "illegal" according to pvanhoof
to add them :) We don't really have a choice though, either we have to use a different
store or hack music ontology onto tracker ... I guess it might be too slow anyway, who
knows.

So Store pushes changes to View, through the traditional notify 'signal'?
HOWEVER, can we even get change notifications from Tracker?
Yes, we get them via dbus
I guess we can emit our own automatically to speed up local view updates
We only get inserts and deletes, but I think updates are actually deletes and inserts so
maybe this will work out okay. ...

MemoryStore:
- what is rdf storage? we kind of need to be DYNAMIC :( can't ask the user to define
  in advance what classes will be stored. HOWEVER we should maintain a list so that
  the view can tell what's valid, and we CAN know from the class what properties it
  can contain.
- tracker just has a table for each class really, so a row for each resource. It's all good.
- how hard is it to write an rdf store really?

Is the generic store concept right for what you want this library to do? Actually yes,
I don't see why Tracker is the only RDF store Charango could work for. We can't easily
use their data structures anyway.

I'm wondering if it's actually a good idea to base things on Redland, and just ignore
its store API (or embrace and extend :) because we get a lot of good stuff like parsing
and dumping completely for free.

Querying!!!:

-> there is one method on musicsource that doesn't transfer too well:
query_relations()

it can do two things:
relation_apid domain is local: for each SUBJECT (=local), return entities related by PREDICATE
                               (relation id)
   => we need to know subject type, subject id and predicate id
relation_apid range is local:  for each OBJECT (=local), return each entity that refers to it
                               with PREDICATE
   => we need to know subject (=foreign) type, predicate id and object (=local) id

Can these still be one function that takes subject type/id pair, predicate id and object id,
with either object id or subject id being optional?
or:
  get_object_relations, get_subject_relations?
  get_functional_relations, get_inverse_functional_relations?
I like these, need to read a bit more about what they could be ...
* Also, would it help to add foreach() variants of these? I'm not sure that it would
  in these cases .. mostly view joins.

Views thoughts:
 -> is the fundamental structure still the same? ie. the configuration lists the Classes
    in an order in which they can be connected. The view then has a set of columns to
    extract from the resources on each line to actually display.
    So the presentation and structure are separate in effetc.
    I think this is the right thing to do still because:
      - reordering columns is easy
      - the config makes more sense
      - it generally just seems a better way now I think about it


General things
--------------------------------------

* I don't like the _noerror variants of some functions, but I don't like having
  ugly try { } catch { } blocks around all my code either. And I don't like the
  "unhandled exception" warnings, but only sometimes because other times I do
  want it. Handle this one, Vala!

* Don't distribute ontologies with charango. That should be up to the
  applications that use them (since it's their API) or Tracker (if they want to
  delegate the responsibility)

Minor things
--------------------------------------

* Core
	Should we store namespace URI's with the trailing # and / or without? The
	overwhelming convention seems to be that they should have the #, but it
	feels slightly weird to require that ..

* Tests
	Use valadate? http://gitorious.org/valadate/pages/Home
	It is a lot like what we use now but needs a new runner and the test to be
	linked as a library (which seems annoying because you can't run the test as
	an exe). Has some nice API extensions like wait_for_signal() and stuff.

Blue sky things
--------------------------------------

* Thought experiment: how hard would it be to handle live updates to the
  known set of ontologies? I doubt there's a real use case since this is a
  library for the desktop but let's think: to remove a class, just replace its
  instance with a tombstone and prevent its use .. to add one, it's even easier.
  From a storage point of view the problem is much harder but from our position
  as a view library we just need update the view :)

* Would be cool to connect to Tracker at a lower level: the initial Tracker layer
  will send SPARQL queries over DBUS to be rewritten in SQL, converted to VM code,
  run in SQLite, parsed into GVariants, send back over DBus and then converted
  into objects. Really we could just read the objects from the Tracker db
  directly, we aren't doing any querying beyond simple SQL joins (well, complex
  SQL joins) so it's just a matter of being a tracker hacker ...

Fixes in other projects
-----------------------

* waf
	Add gtester support to waf

* Vala
	Use built-in test support:
	  https://asabil.wordpress.com/2009/01/23/vala-and-unit-testing/
	or valadata?

	Update raptor.vapi in upstream Vala, merge redland.vapi

* Tracker
	Some of our ontology state code is duplicated in Tracker, although also have
	their own additions like notification tracking. We each have our own
	requirements, but maybe a standardised grdf library (I'd like to call it
	Greenland :) could become the superclass for both of us.

	Issues:
	  -> the redland dependency: I guess they don't like it because the more libs
	  you link to the slower you are, which isn't bad reasoning. Also it doesn't
	  do a huge amount more for us than parse. I basically like it because we
	  can read ontologies from the internet.
	  -> name ideas :) I like Facts (good namespace). Or Greenland, but we can't
	  really use gl_ namespace :) GRDF sounds like a dog dying.
	  -> a big win on the Tracker side is that they cache the ontologies in a
	     GVDB. This is a good idea. GRDF would be a good place to put the shared
	     ontologies too since it would be a smaller dep than the whole of tracker? 
	     Although they do like to be in control, maybe they could still be but
	     just in charge of the ontologies for the whole desktop instead of just
	     in tracker.. since obviously we need to agree on them regardless. This is
	     some pretty blue sky thinking!
	  -> it could become a bit more generic and be a generic data/sharing/SOA
	     library .. maybe built on top of libsoup ! This would need a new name
	     I guess, like SoaLib or libdata or something like that. Why do you
	     always worry about names!

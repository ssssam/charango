Charango 0.3.0 ...

To do (stuff I won't really do)
-------------------------------

-> disable static build, add a 'waf run' command similar to 'libtool exec' to fix ld_library_path.

-> Fix waf no longer keeping the vala c output because a c file is included in the build

* Bug https://bugzilla.gnome.org/show_bug.cgi?id=649644
  - Vala doesn't support returning the test function .. perhaps what
    we really want is a push_log_handler/pop_log_handler function anyway.
    Or a whole vala_test_functions thing - maybe this stuff can go in Valadate?

* Tracing - using #ifdef's correctly, we can making tracing free when disabled.
  Currently ... we don't.

  -> I guess you also need a resources hash. Per-namespace to avoid hashing the
     whole URI each time.
     Also, it makes far more sense to index namespaces on their prefix than on
     the URI .. is it fair to make unique prefixes a requirement? There's ultimately
     no reason you can't just invent one/add a postfix index if the user can't make
     it unique, so this idea is definitely a mover and shaker

  -> Do you need entity Id's? I'm not sure at the moment. We can probably use
     pointers most places.

To do
-----

get/set properties should work again - actually store the data :)

6. add accessors for concept properties that wrap get/set_entity etc.

* Write up a proper spec

* Add an 'ontology-browser' example - simple Gtk+ 3 app

* Since you're using Vala, why not use GValue for values since it's built in!!

* class.to_string(): don't put : in non-key URI's

* Support key URI's etc.
  ->

* don't access members, make them properties and use accessors - this is a library !

-> We should start warning on unrecognised predicates for classes and properties too.

*  Get 'basic' example working - simply create an entity


* Relationship properties

* The store/source interface (beginnings are stashed)

-> need a couple of thoughts on architecture. Heard a bit about MVC recently
   and how change notifications and editing should go in the controller,
   not the model. I don't really buy this (or get it). Our architecture is
   this

   Data store:   tracker,  in memory     
                                         //    web endpoints:    Data source
        transactional CRUD             ->   model: stores data, provides change
                                            notification
                 ^^ vv        vv     ^^  vv
              info editor   views   extractor

   I guess it does seem like a reasonable design to at least put the
   CRUD stuff in a separate API, even if its just an interface, because
   web data sources will be immutable. Perhaps then you have:

        Charango.Source    : querying and change notification
          Charango.Store   : CRUD

        .. that's astonishingly simple. I like it.

* an in-memory store

-> write some tests

-> write some of calliope :)
    - extractor
    - text mode playback !!

Might be nice to have read-only entitys? You can't edit them unless (a) they're
new or (b) they've been checked out. Then again, it's just a flag, it doesn't
really allow us any easier logic.

How could you possibly implement reference tracking?
Vala REALLY needs #define etc ... much as they would probably hate it.
There's simply no other way to do entity ref tracking in a transparent
way, and it was REALLY useful. Wait actually you might be able to do
it using default parameters, even if you have to write the actual
Entity code in C. Better look into this business.


Things still to handle:
rdfs:isDefinedBy on classes (check it matches where we have added it :)


* Share the vala bindings for librdf


WHERE FROM is a slight issue - we can get them on disk from various locations
(apps own dir, tracker dir) or from the net (canonical sources).

There can be discrepencies/version mismatches, so this is important stuff .. I
guess we should check things when they are stored (perhaps optionally) that they
map to the ontologies stored by *that* storage backend. Ie. we could check that the
data fits an installed Tracker ontology. Or just check the lastModifiedDate property.

Write a generic charango-driven browser for all semantic data sources!!!
See: nepomukshell/ nepsak from KDE


So we need:
* Model
  Charango.Store
  -> Charango.GenericStore, Charango.TrackerStore, Charango.SQLiteStore
  Charango.Source
  -> for web API end points, maybe pluggable? Seems like overkill.
  Charango.Union
  -> for aggregated data sources.

* View ..
  Charango.View, Charango.TreeView .. in the distant future maybe some
  cool faceted browing viewers :)

* Other stuff..
  in the Ontology, we have Classes and Properties
  in the data store, we have Resources ..

Backends: pluggable on run or compile?
ie. if charango is built without tracker support, do we allow calliope to link to .trackerStore?
-> certainly don't want a hard dep on tracker, what about win32? etc.
-> I guess a store needs an available? method

I'm rethinking not requiring the Tracker dep. Surely implementing a simple RDF store
using SQLite is basically reimplementing tracker without the DBUS? Since the only
place it's really hard to expect tracker is win32, surely we can just build it there
using some hacks if necessary.

Truth is Tracker don't want custom ontologies, and it is "illegal" according to pvanhoof
to add them :) We don't really have a choice though, either we have to use a different
store or hack music ontology onto tracker ... I guess it might be too slow anyway, who
knows.

So Store pushes changes to View, through the traditional notify 'signal'?
HOWEVER, can we even get change notifications from Tracker?
Yes, we get them via dbus
I guess we can emit our own automatically to speed up local view updates
We only get inserts and deletes, but I think updates are actually deletes and inserts so
maybe this will work out okay. ...

MemoryStore:
- what is rdf storage? we kind of need to be DYNAMIC :( can't ask the user to define
  in advance what classes will be stored. HOWEVER we should maintain a list so that
  the view can tell what's valid, and we CAN know from the class what properties it
  can contain.
- tracker just has a table for each class really, so a row for each resource. It's all good.
- how hard is it to write an rdf store really?

Is the generic store concept right for what you want this library to do? Actually yes,
I don't see why Tracker is the only RDF store Charango could work for. We can't easily
use their data structures anyway.

I'm wondering if it's actually a good idea to base things on Redland, and just ignore
its store API (or embrace and extend :) because we get a lot of good stuff like parsing
and dumping completely for free.

Querying!!!:

-> there is one method on musicsource that doesn't transfer too well:
query_relations()

it can do two things:
relation_apid domain is local: for each SUBJECT (=local), return entities related by PREDICATE
                               (relation id)
   => we need to know subject type, subject id and predicate id
relation_apid range is local:  for each OBJECT (=local), return each entity that refers to it
                               with PREDICATE
   => we need to know subject (=foreign) type, predicate id and object (=local) id

Can these still be one function that takes subject type/id pair, predicate id and object id,
with either object id or subject id being optional?
or:
  get_object_relations, get_subject_relations?
  get_functional_relations, get_inverse_functional_relations?
I like these, need to read a bit more about what they could be ...
* Also, would it help to add foreach() variants of these? I'm not sure that it would
  in these cases .. mostly view joins.

Views thoughts:
 -> is the fundamental structure still the same? ie. the configuration lists the Classes
    in an order in which they can be connected. The view then has a set of columns to
    extract from the resources on each line to actually display.
    So the presentation and structure are separate in effetc.
    I think this is the right thing to do still because:
      - reordering columns is easy
      - the config makes more sense
      - it generally just seems a better way now I think about it


General things
--------------------------------------

* Set up log domain - how do you do this in vala?

* I don't like the _noerror variants of some functions, but I don't like having
  ugly try { } catch { } blocks around all my code either. And I don't like the
  "unhandled exception" warnings, but only sometimes because other times I do
  want it. Handle this one, Vala!

* Don't distribute ontologies with charango. That should be up to the
  applications that use them (since it's their API) or Tracker (if they want to
  delegate the responsibility)

* Value storage is enourmously inefficient currently because we store all
  integer values as a pointer to a heap-allocated 64 bit int. I guess the
  ideal system is to dynamically store numeric values in the smallest
  possible size, so word-size by default and then up to bigint if
  necessary. We mainly store strings, so it is probably worth having a
  32-bit struct on 32-bit pointer systems. How would storing ints based
  on value work? ... complicatedly.

* I had  an idea (not sure if necessary) that we should have one giant 'Resource'
  hash table that could somehow identify a URI as type, class, property or entity.
  This could just be done with a pointer, if we gave maybe the base type values
  Vala object types as well.
   -> if you did, the id numbers for resources might be useless - just refer to
      them by pointer


Minor things
--------------------------------------

* Core
	Should we store namespace URI's with the trailing # and / or without? The
	overwhelming convention seems to be that they should have the #, but it
	feels slightly weird to require that ..

* Tests
	Use valadate? http://gitorious.org/valadate/pages/Home
	It is a lot like what we use now but needs a new runner and the test to be
	linked as a library (which seems annoying because you can't run the test as
	an exe). Has some nice API extensions like wait_for_signal() and stuff.

	Organise the tests .. unit, functional, integration, live ...

Blue sky things
--------------------------------------

* Thought experiment: how hard would it be to handle live updates to the
  known set of ontologies? I doubt there's a real use case since this is a
  library for the desktop but let's think: to remove a class, just replace its
  instance with a tombstone and prevent its use .. to add one, it's even easier.
  From a storage point of view the problem is much harder but from our position
  as a view library we just need update the view :)

* Would be cool to connect to Tracker at a lower level: the initial Tracker layer
  will send SPARQL queries over DBUS to be rewritten in SQL, converted to VM code,
  run in SQLite, parsed into GVariants, send back over DBus and then converted
  into objects. Really we could just read the objects from the Tracker db
  directly, we aren't doing any querying beyond simple SQL joins (well, complex
  SQL joins) so it's just a matter of being a tracker hacker ...

Fixes in other projects
-----------------------

* waf
	Add gtester support to waf

* Vala
	Use built-in test support:
	  https://asabil.wordpress.com/2009/01/23/vala-and-unit-testing/
	or valadata?

	Update raptor.vapi in upstream Vala, merge redland.vapi

* Tracker
	Some of our ontology state code is duplicated in Tracker, although also have
	their own additions like notification tracking. We each have our own
	requirements, but maybe a standardised grdf library (I'd like to call it
	Greenland :) could become the superclass for both of us.

	Issues:
	  -> the redland dependency: I guess they don't like it because the more libs
	  you link to the slower you are, which isn't bad reasoning. Also it doesn't
	  do a huge amount more for us than parse. I basically like it because we
	  can read ontologies from the internet.
	  -> name ideas :) I like Facts (good namespace). Or Greenland, but we can't
	  really use gl_ namespace :) GRDF sounds like a dog dying.
	  -> a big win on the Tracker side is that they cache the ontologies in a
	     GVDB. This is a good idea. GRDF would be a good place to put the shared
	     ontologies too since it would be a smaller dep than the whole of tracker? 
	     Although they do like to be in control, maybe they could still be but
	     just in charge of the ontologies for the whole desktop instead of just
	     in tracker.. since obviously we need to agree on them regardless. This is
	     some pretty blue sky thinking!
	  -> it could become a bit more generic and be a generic data/sharing/SOA
	     library .. maybe built on top of libsoup ! This would need a new name
	     I guess, like SoaLib or libdata or something like that. Why do you
	     always worry about names!


Waiting for
-----------

Vala 0.12.1:
  https://bugzilla.gnome.org/show_bug.cgi?id=645178
